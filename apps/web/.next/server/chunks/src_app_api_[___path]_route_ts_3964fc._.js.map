{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/apps/web/src/app/api/[...path]/route.ts"],"sourcesContent":["/**\r\n * Next.js API Route Proxy\r\n * \r\n * This route proxies all API requests to the backend API server.\r\n * It handles cookie rewriting to ensure cookies work when web app and API\r\n * run on different origins (e.g., localhost:3000 vs localhost:4000).\r\n * \r\n * In development, this allows cookies to be set correctly even when\r\n * the backend API is on a different port.\r\n */\r\n\r\nimport { NextRequest, NextResponse } from 'next/server';\r\n\r\nconst API_BASE = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:4000';\r\n\r\n// Helper to handle params (Next.js 15+ params is a Promise)\r\nasync function getPath(params: { path: string[] } | Promise<{ path: string[] }>): Promise<string[]> {\r\n  const resolved = await params;\r\n  return resolved.path;\r\n}\r\n\r\nexport async function GET(request: NextRequest, { params }: { params: { path: string[] } | Promise<{ path: string[] }> }) {\r\n  const pathSegments = await getPath(params);\r\n  return proxyRequest(request, pathSegments, 'GET');\r\n}\r\n\r\nexport async function POST(request: NextRequest, { params }: { params: { path: string[] } | Promise<{ path: string[] }> }) {\r\n  const pathSegments = await getPath(params);\r\n  return proxyRequest(request, pathSegments, 'POST');\r\n}\r\n\r\nexport async function PUT(request: NextRequest, { params }: { params: { path: string[] } | Promise<{ path: string[] }> }) {\r\n  const pathSegments = await getPath(params);\r\n  return proxyRequest(request, pathSegments, 'PUT');\r\n}\r\n\r\nexport async function PATCH(request: NextRequest, { params }: { params: { path: string[] } | Promise<{ path: string[] }> }) {\r\n  const pathSegments = await getPath(params);\r\n  return proxyRequest(request, pathSegments, 'PATCH');\r\n}\r\n\r\nexport async function DELETE(request: NextRequest, { params }: { params: { path: string[] } | Promise<{ path: string[] }> }) {\r\n  const pathSegments = await getPath(params);\r\n  return proxyRequest(request, pathSegments, 'DELETE');\r\n}\r\n\r\nasync function proxyRequest(\r\n  request: NextRequest,\r\n  pathSegments: string[],\r\n  method: string,\r\n) {\r\n  try {\r\n    const path = `/api/${pathSegments.join('/')}`;\r\n    const url = new URL(path, API_BASE);\r\n    \r\n    // Forward query parameters\r\n    request.nextUrl.searchParams.forEach((value, key) => {\r\n      url.searchParams.append(key, value);\r\n    });\r\n\r\n    // Prepare headers\r\n    const headers = new Headers();\r\n    request.headers.forEach((value, key) => {\r\n      // Don't forward host, connection, and other hop-by-hop headers\r\n      if (\r\n        !['host', 'connection', 'keep-alive', 'transfer-encoding', 'upgrade'].includes(\r\n          key.toLowerCase(),\r\n        )\r\n      ) {\r\n        headers.set(key, value);\r\n      }\r\n    });\r\n\r\n    // Forward cookies from the request\r\n    const cookies = request.cookies.getAll();\r\n    if (cookies.length > 0) {\r\n      headers.set(\r\n        'cookie',\r\n        cookies.map((c) => `${c.name}=${c.value}`).join('; '),\r\n      );\r\n    }\r\n\r\n    // Get request body if present\r\n    let body: BodyInit | undefined;\r\n    if (method !== 'GET' && method !== 'HEAD') {\r\n      try {\r\n        body = await request.text();\r\n      } catch {\r\n        // No body\r\n      }\r\n    }\r\n\r\n    // Make the proxied request\r\n    const response = await fetch(url.toString(), {\r\n      method,\r\n      headers,\r\n      body,\r\n    });\r\n\r\n    // Create response with proxied status and headers\r\n    const responseHeaders = new Headers();\r\n    response.headers.forEach((value, key) => {\r\n      // Rewrite Set-Cookie headers to remove domain restriction\r\n      // This allows cookies to work when proxying between different origins\r\n      if (key.toLowerCase() === 'set-cookie') {\r\n        // Remove domain attribute to allow cookie to be set for current origin\r\n        const cookieValue = value\r\n          .split(';')\r\n          .map((part) => part.trim())\r\n          .filter((part) => !part.toLowerCase().startsWith('domain='))\r\n          .join('; ');\r\n        responseHeaders.append('set-cookie', cookieValue);\r\n      } else {\r\n        responseHeaders.set(key, value);\r\n      }\r\n    });\r\n\r\n    // Preserve Content-Type from backend\r\n    const contentType = response.headers.get('content-type');\r\n    if (contentType) {\r\n      responseHeaders.set('content-type', contentType);\r\n    }\r\n\r\n    // Get response body\r\n    const responseBody = await response.text();\r\n\r\n    // If response is not OK, ensure we return proper JSON error\r\n    if (!response.ok) {\r\n      let errorData: any;\r\n      try {\r\n        errorData = JSON.parse(responseBody);\r\n      } catch {\r\n        // If response is not JSON, wrap it\r\n        errorData = { message: responseBody || response.statusText || 'Request failed' };\r\n      }\r\n      \r\n      // Log error for debugging\r\n      console.error(`[API Proxy] Backend error: ${response.status} ${method} ${path}`, errorData);\r\n      \r\n      return NextResponse.json(errorData, {\r\n        status: response.status,\r\n        statusText: response.statusText,\r\n        headers: responseHeaders,\r\n      });\r\n    }\r\n\r\n    return new NextResponse(responseBody, {\r\n      status: response.status,\r\n      statusText: response.statusText,\r\n      headers: responseHeaders,\r\n    });\r\n  } catch (error: any) {\r\n    console.error('[API Proxy] Error proxying request:', error);\r\n    const errorMessage = error?.message || 'Unknown error';\r\n    \r\n    // Check if it's a connection error\r\n    if (errorMessage.includes('ECONNREFUSED') || errorMessage.includes('fetch failed')) {\r\n      return NextResponse.json(\r\n        { \r\n          message: 'Backend API server is not running. Please start the API server on port 4000.',\r\n          error: 'Connection refused',\r\n          path: pathSegments.join('/'),\r\n        },\r\n        { status: 503 }\r\n      );\r\n    }\r\n    \r\n    return NextResponse.json(\r\n      { \r\n        message: 'Failed to proxy request to backend API',\r\n        error: errorMessage,\r\n        path: pathSegments.join('/'),\r\n      },\r\n      { status: 502 }\r\n    );\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 158, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}